\section{Тест производительности}


Тест производительности представляет из себя следующее: сортировка массива из одного миллиона пар \enquote{ключ-значение}. Все пары сгенерированы случайным образом, ключ - дата в формате, соответствующем заданию, а значение - случайная строка длины от 1 до 2048, состоящая из строчных и заглавных букв латинского алфавита.

\begin{alltt}
\$> g++ -Wall -Werror -Wextra -Wpedantic benchmark.cpp -std=c++17
\$> ./a.out < input
\$> grep -e "Time:" LSD.txt
Time: 286ms
\$> grep -e "Time:" stable_sort.txt
Time: 1034ms
\$> diff LSD.txt stable_sort.txt
1000001c1000001
< Time: 286ms
---
> Time: 1034ms
\end{alltt}

Как видно, поразрядная сортировка выиграла у $std::stable\_sort$. Это происходит из-за того, что $std::stable\_sort$ реализуется на алгоритме $merge$ $sort$, который работает за $\mathcal{O}(n\log{}n)$, в то время, как реализованная мной $LSD$ сортировка работает за время $\mathcal{O}(nk)$, где $k$ - максимальное число разрядов в числе. Т.к. в моей сортировке все числа рассматриваются в 256-ичной системе счисления, $k$ очень мало. Например, для даты $26.02.2024$ $k$ будет чуть больше трёх. 

\pagebreak

